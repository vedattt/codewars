// Kata link: https://www.codewars.com/kata/55cf3b567fc0e02b0b00000b/javascript

/* Terrible solution due to how WASTEFUL it is at generating partitions
   but I'm proud of it for solving it on my own as an amateur (for now) */
function part (n) { 

  let parts = [null, [[1]]/*, [[1,1]], [[2,1]], [[3,1], [2,2]],... */], // array of arrays of partition arrays :)
            // null is to shift the array's index to match it with actual numbers. (8's partitions => parts[8])
      lengths = []; // explained at the end
  
  for (let int = 2; int <= n; int++) { // generating all partitions for i until n
    parts[int] = [];
    lengths[int] = 0;
    
    for (let k = 1; 2 * k <= int ; k++) { // generate partitions with 2 pieces
      parts[int].push([int - k, k]);
      lengths[int]++;
    }
    
    let cache = {}; // cache will be used to prevent duplicate partitions
    parts[int].forEach(e => cache[e.join()] = true);
    
    for (let j = 0, len0 = lengths[int]; j < len0; j++) { // j is for existing 2-piece partitions of int
      
      for (let p = 0, len1 = lengths[parts[int][j][0]]; p < len1; p++) { /* p is for all the possible 
                                                                            partitions from smaller numbers */
        let prt = parts[ parts[int][j][0] ][p], // partition of a single piece from the 2-piece partitions
            ins = parts[int][j][1]; // the other piece of the 2-piece partition
        
        let partition = prt.slice(); // this block will insert piece into the other piece's partition 
        for (let idx = 0, len2 = prt.length; idx < len2; idx++) {
          if (prt[idx] < ins) { // preserving the newly generated partition's descending order
            partition.splice(idx, 0, ins);
            break;
          } else if (idx === prt.length - 1) partition.push(ins);
        }
        
        let keyOfPartition = partition.join();
        if (!cache[keyOfPartition]) { // save the partition if it doesn't exist yet
          parts[int].push(partition);
          cache[keyOfPartition] = true;
          lengths[int]++;
        }
      }
    }
  }
  
  let prod = [n]; // generate sorted array of unique products from all of n's partitions
  for (let i = 0, len = lengths[n]; i < len; i++) {
    let product = parts[n][i].reduce((a, e) => a * e, 1);
    if (prod.indexOf(product) === -1) prod.push(product);
  }
  prod = prod.sort((a, b) => a - b);
  
  let range = prod[prod.length - 1] - prod[0], // get properties to return
      average = prod.reduce((a, e) => a + e, 0) / prod.length,
      median = prod.length % 2 ? prod[Math.floor(prod.length / 2)] :
                                  (prod[prod.length/2] + prod[prod.length/2 - 1]) / 2;
  
  return `Range: ${range} Average: ${average.toFixed(2)} Median: ${median.toFixed(2)}`;
} // function can handle up to n = 49 which will have more than 32.282.577 loops
/*
  How it works [ I think... :) ]:
  - We divide numbers into two pieces: ([5] becomes [3, 2] or [4, 1] for example)
  
  - To generate partitions with more than two pieces, 
    we use partitions that were already generated by smaller numbers:
    ([3, 2] can be partitioned again as [(a partition of 3), 2] which might be [2, 1, 2] for example)
    
  - We sort these partitions to make duplicates obvious, then convert them to strings 
    and create a key for them in a cache object to prevent duplicate partitions.
    
  - The amount of generated partitions for any number are always "naturally" counted in the "lengths" array.
  
  - This process is repeated until all partitions of n (parts[n]) are generated.
  
  - The rest is easy; calculate products of all partitions, sort them, get range/average/median from its array.
  
  Things I've learnt (while optimizing):
  - Using objects as cache instead of arrays is *SIGNIFICANTLY* faster. ([...].indexOf(var) vs {...}[var])
  
  - If inserting a number into an otherwise sorted array, finding the insertion's correct index 
    is far faster than sorting the entire array again. (obviously...).
    
  - Caching lengths in loops might offer a rarely critical performance gain.
*/